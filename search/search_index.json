{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Introduction Projectile motion is a cornerstone of classical mechanics, describing the path of an object under the influence of gravity. This motion occurs in numerous real-world scenarios, such as sports (e.g., throwing a ball), engineering (e.g., rocket trajectories), and astrophysics (e.g., launching satellites). The task here is to investigate how the horizontal range of a projectile varies with the launch angle, a question that has both theoretical significance and practical implications. This analysis is intriguing because it combines simple principles with complex outcomes. The motion of a projectile is governed by both linear and quadratic relationships, making it a versatile topic for exploration. By examining how different initial conditions\u2014such as the initial velocity, gravitational acceleration, and launch height\u2014affect the trajectory, we can develop deeper insights into both idealized and real-world scenarios. Motivation Understanding the range of a projectile as a function of the launch angle is of great importance in a variety of fields. In sports, optimizing the angle of projection can improve performance, such as in basketball, soccer, or golf, where the goal is to reach a target with maximum efficiency. Engineers apply the principles of projectile motion to the design of vehicles such as rockets and missiles, where precise calculations of the launch angle and velocity are crucial for accurate targeting and range estimation. In addition, this problem serves as an entry point to explore more complex systems, such as the effects of air resistance or uneven terrain on projectile trajectories. By building on this simple model, we can gain a better understanding of how real-world forces and conditions influence the behavior of projectiles. Thus, while the problem might appear straightforward, it offers an opportunity to delve into the complexities of motion in a way that has both practical and theoretical value. Theoretical Foundation 1. Governing Equations of Motion The motion of a projectile in the absence of air resistance is governed by Newton's laws of motion. To simplify the analysis, we divide the motion into horizontal and vertical components. Horizontal Motion : $$ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t $$ Where: - \\(x(t)\\) is the horizontal position at time \\(t\\) , - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(t\\) is the time elapsed. Since there is no acceleration in the horizontal direction (assuming no air resistance), the horizontal velocity remains constant. Show Python Code import numpy as np import matplotlib.pyplot as plt # Parameters for the plot v_0_values = [10, 20, 30] # Different initial velocities theta = 45 # Launch angle in degrees g = 9.81 # Acceleration due to gravity (m/s^2) # Create a figure plt.figure(figsize=(10, 6)) # Loop over different initial velocities to plot horizontal motion for each case for v_0 in v_0_values: t_max = 2 * v_0 * np.sin(np.radians(theta)) / g # Total time of flight t = np.linspace(0, t_max, 1000) # Time values from 0 to t_max x_t = v_0 * np.cos(np.radians(theta)) * t # Horizontal position equation # Plot the horizontal motion for each initial velocity plt.plot(t, x_t, label=f'v_0 = {v_0} m/s', linewidth=2) # Add labels, title, and grid plt.title(r'Horizontal Motion of a Projectile: $x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t$', fontsize=14) plt.xlabel('Time (seconds)', fontsize=12) plt.ylabel('Horizontal Position (meters)', fontsize=12) plt.legend(loc='upper left', fontsize=10) plt.grid(True, which='both', linestyle='--', linewidth=0.5) # Use a default style for better compatibility plt.style.use('ggplot') # Show the plot plt.tight_layout() plt.show() This graph shows how horizontal motion changes over time. The horizontal motion equation \\( x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\) is used to describe it. Here, horizontal distance increases linearly with time \\( t \\) . The graph illustrates how the horizontal distances of projectiles with different initial velocities (10 m/s, 20 m/s, 30 m/s) change over time. Vertical Motion : $$ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ Where: - \\( y(t) \\) is the vertical position at time \\( t \\) , - \\( v_0 \\cdot \\sin(\\theta) \\) is the vertical component of the initial velocity, - \\( g \\) is the gravitational acceleration ( \\( \\approx 9.81 \\, \\text{m/s}^2 \\) on Earth), - \\( t \\) is the time elapsed . The projectile reaches the maximum height when the vertical velocity component becomes zero. From this point, it starts descending until it reaches the ground. The total time of flight can be found by solving the vertical motion equation for when \\( y(t) = 0 \\) . Show Python Code import numpy as np import matplotlib.pyplot as plt # Parameters for the plot v_0 = 20 # Initial velocity in m/s theta = 45 # Launch angle in degrees g = 9.81 # Acceleration due to gravity (m/s^2) # Total time of flight (when y(t) = 0) t_max = 2 * v_0 * np.sin(np.radians(theta)) / g # Total time for vertical motion # Time values from 0 to t_max t = np.linspace(0, t_max, 1000) # Vertical position equation: y(t) = v_0 * sin(\u03b8) * t - (1/2) * g * t^2 y_t = v_0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 # Create a figure with a clean and modern style plt.figure(figsize=(10, 6)) # Plot the vertical motion with a clean, minimalistic style plt.plot(t, y_t, label=r'$y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2$', color='teal', linewidth=2) # Highlight the maximum height (where the vertical velocity becomes zero) t_max_height = v_0 * np.sin(np.radians(theta)) / g y_max_height = v_0 * np.sin(np.radians(theta)) * t_max_height - 0.5 * g * t_max_height**2 # Use a bold marker for the maximum height plt.plot(t_max_height, y_max_height, 'o', markersize=10, color='coral') # Adjusting annotation position for better readability plt.annotate(f'Max Height: {y_max_height:.2f} m', xy=(t_max_height, y_max_height), xytext=(t_max_height + 0.5, y_max_height + 2), # Slightly moved up and right arrowprops=dict(arrowstyle='->', color='black'), fontsize=12, color='black') # Clean, minimalistic title and labels plt.title('Vertical Motion of a Projectile', fontsize=16, fontweight='bold', color='darkblue') plt.xlabel('Time (seconds)', fontsize=12, color='black') plt.ylabel('Vertical Position (meters)', fontsize=12, color='black') # Minimalist grid plt.grid(True, which='both', linestyle='-', linewidth=0.5, color='gray') # Remove box around the legend plt.legend(loc='upper right', fontsize=12, frameon=False) # Tight layout for a cleaner look plt.tight_layout() # Show the plot plt.show() This graph shows the vertical motion of a projectile. The red point marks the maximum height of approximately 10.19 meters . 2. Time of Flight and Range To determine the time of flight, we set \\( y(t) = 0 \\) , which corresponds to the point when the projectile hits the ground. Solving for \\( t \\) gives: \\[ t_{\\text{total}} = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] This is the total time the projectile spends in the air. The range \\( R \\) , or the horizontal distance traveled, is then given by: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot t_{\\text{total}} = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Thus, the range \\( R \\) depends on the initial velocity \\( v_0 \\) , the gravitational acceleration \\( g \\) , and the launch angle \\( \\theta \\) . Example Problem: Projectile Motion A ball is projected with an initial speed of 20 m/s at an angle of 30\u00b0 above the horizontal. Assume there is no air resistance and take the acceleration due to gravity as 9.81 m/s\u00b2 . Questions: What is the total time the ball stays in the air? How far horizontally does the ball travel before hitting the ground? What is the maximum height the ball reaches? Solution: Given: - \\( v_0 = 20 \\, \\text{m/s} \\) - \\( \\theta = 30^\\circ \\) - \\( g = 9.81 \\, \\text{m/s}^2 \\) We use the following formulas: Time of Flight : $$ t_{\\text{total}} = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} $$ $$ t_{\\text{total}} = \\frac{2 \\cdot 20 \\cdot \\sin(30^\\circ)}{9.81} = \\frac{20}{9.81} \\approx \\boxed{2.04 \\, \\text{seconds}} $$ Range (Horizontal Distance) : $$ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} $$ $$ R = \\frac{400 \\cdot \\sin(60^\\circ)}{9.81} = \\frac{400 \\cdot 0.866}{9.81} \\approx \\frac{346.4}{9.81} \\approx \\boxed{35.3 \\, \\text{meters}} $$ Maximum Height : $$ H_{\\text{max}} = \\frac{v_0^2 \\cdot \\sin^2(\\theta)}{2g} $$ $$ H_{\\text{max}} = \\frac{400 \\cdot \\sin^2(30^\\circ)}{2 \\cdot 9.81} = \\frac{400 \\cdot 0.25}{19.62} = \\frac{100}{19.62} \\approx \\boxed{5.1 \\, \\text{meters}} $$ Final Answers: Time of Flight: 2.04 s Range: 35.3 m Maximum Height: 5.1 m 3. Analysis of the Range as a Function of the Angle of Projection The range equation \\( R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\) shows that the range is a function of the angle \\( \\theta \\) . Specifically: The function \\( \\sin(2\\theta) \\) is maximized when \\( 2\\theta = 90^\\circ \\) , which corresponds to \\( \\theta = 45^\\circ \\) . Therefore, the range is maximized when the launch angle is \\( 45^\\circ \\) . If the angle is less than or greater than 45\u00b0, the range decreases. This means that, for a given initial velocity, the optimal launch angle for maximizing the range is 45\u00b0. However, the behavior of the range is also influenced by other factors, such as the initial velocity \\( v_0 \\) and the acceleration due to gravity \\( g \\) . For example, increasing the initial velocity \\( v_0 \\) will increase the range, while increasing \\( g \\) (such as on a planet with stronger gravity) will reduce the range. Analysis of the Range as a Function of the Angle of Projection The range equation: \\[ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] shows that the range is a function of the launch angle \\( \\theta \\) . This equation tells us several important things: The function \\( \\sin(2\\theta) \\) reaches its maximum value when \\( 2\\theta = 90^\\circ \\) , or \\( \\theta = 45^\\circ \\) . Therefore, the maximum range occurs when the projectile is launched at a 45\u00b0 angle. If the angle is less than or greater than 45\u00b0 , the range decreases. Range vs. Launch Angle The plot below shows how the range changes with the angle of projection (assuming \\( v_0 = 20 \\, \\text{m/s} \\) ): Show Python Code import numpy as np import matplotlib.pyplot as plt v0 = 20 # m/s g = 9.81 # m/s^2 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) R = (v0**2) * np.sin(2 * angles_rad) / g plt.figure(figsize=(10, 5)) plt.plot(angles_deg, R, color='orange') plt.title('Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.tight_layout() plt.savefig(\"image-7.png\", dpi=300) plt.show() - The graph is symmetric about 45\u00b0 . - Launch angles like 30\u00b0 and 60\u00b0 produce the same range . Why are 30\u00b0 and 60\u00b0 the same? This is because: \\[ \\sin(2 \\cdot 30^\\circ) = \\sin(60^\\circ) = \\sin(120^\\circ) = \\sin(2 \\cdot 60^\\circ) \\] So for any two angles that add up to 90\u00b0 , the range will be the same. Real-World Considerations Increasing the initial velocity \\( v_0 \\) will increase the range. Increasing gravitational acceleration \\( g \\) (e.g., on Jupiter) will decrease the range. On the Moon , where \\( g \\approx 1.62 \\, \\text{m/s}^2 \\) , the same launch parameters would yield a much longer range . Think About It What would happen if air resistance were considered? Would 45\u00b0 still be the optimal angle for maximum range? Practical Applications 1. Real-World Adaptations In real-world applications, projectile motion is not always idealized. For instance: Uneven Terrain : If a projectile is launched from a height or lands on uneven terrain, the equations above need to be adjusted to account for changes in the initial position and the varying height of the landing spot. Air Resistance : The presence of air resistance complicates the analysis, as it introduces a force that opposes the motion of the projectile, affecting both the horizontal and vertical components of the velocity. This effect is typically modeled by differential equations, but a simple analytic solution is not available. Numerical methods are often used to simulate these cases. Wind : Wind can alter the direction and speed of the projectile, affecting both range and trajectory. This factor can be modeled as an additional force applied to the projectile, changing the equations of motion. 2. Computational Simulations A computational tool or simulation can be developed to model projectile motion, allowing for easy visualization of the range as a function of the angle of projection for various initial velocities and gravitational accelerations. Below is a simple Python code to simulate and plot the range as a function of the angle of projection for various initial velocities: Show Python Code import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # acceleration due to gravity (m/s^2) v_0 = 20 # initial velocity in m/s # Function to calculate the range def calculate_range(v_0, theta): return (v_0**2 * np.sin(2 * np.radians(theta))) / g # Angles of projection angles = np.linspace(0, 90, 100) # Calculate range for each angle ranges = [calculate_range(v_0, angle) for angle in angles] # Plot the range vs angle plt.figure(figsize=(8, 6)) plt.plot(angles, ranges) plt.title('Range of a Projectile as a Function of the Angle of Projection') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.show() Conclusion In this analysis, we explored the fundamental equations governing projectile motion and derived the relationship between the range and the launch angle. We found that the range is maximized at an angle of 45\u00b0, which is intuitive from both a theoretical and practical standpoint. By considering other factors like initial velocity and gravitational acceleration, we can predict how these variables influence the trajectory of a projectile. The idealized model of projectile motion provides a solid foundation for understanding the basic principles at play. However, real-world applications often require additional considerations, such as air resistance and uneven terrain. As a result, more sophisticated models and computational simulations are necessary for accurately predicting the behavior of projectiles in more complex environments. This investigation not only deepens our understanding of basic mechanics but also highlights the versatility and applicability of projectile motion in various domains, from sports and engineering to space exploration.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#introduction","text":"Projectile motion is a cornerstone of classical mechanics, describing the path of an object under the influence of gravity. This motion occurs in numerous real-world scenarios, such as sports (e.g., throwing a ball), engineering (e.g., rocket trajectories), and astrophysics (e.g., launching satellites). The task here is to investigate how the horizontal range of a projectile varies with the launch angle, a question that has both theoretical significance and practical implications. This analysis is intriguing because it combines simple principles with complex outcomes. The motion of a projectile is governed by both linear and quadratic relationships, making it a versatile topic for exploration. By examining how different initial conditions\u2014such as the initial velocity, gravitational acceleration, and launch height\u2014affect the trajectory, we can develop deeper insights into both idealized and real-world scenarios.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Understanding the range of a projectile as a function of the launch angle is of great importance in a variety of fields. In sports, optimizing the angle of projection can improve performance, such as in basketball, soccer, or golf, where the goal is to reach a target with maximum efficiency. Engineers apply the principles of projectile motion to the design of vehicles such as rockets and missiles, where precise calculations of the launch angle and velocity are crucial for accurate targeting and range estimation. In addition, this problem serves as an entry point to explore more complex systems, such as the effects of air resistance or uneven terrain on projectile trajectories. By building on this simple model, we can gain a better understanding of how real-world forces and conditions influence the behavior of projectiles. Thus, while the problem might appear straightforward, it offers an opportunity to delve into the complexities of motion in a way that has both practical and theoretical value.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-governing-equations-of-motion","text":"The motion of a projectile in the absence of air resistance is governed by Newton's laws of motion. To simplify the analysis, we divide the motion into horizontal and vertical components. Horizontal Motion : $$ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t $$ Where: - \\(x(t)\\) is the horizontal position at time \\(t\\) , - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(t\\) is the time elapsed. Since there is no acceleration in the horizontal direction (assuming no air resistance), the horizontal velocity remains constant. Show Python Code import numpy as np import matplotlib.pyplot as plt # Parameters for the plot v_0_values = [10, 20, 30] # Different initial velocities theta = 45 # Launch angle in degrees g = 9.81 # Acceleration due to gravity (m/s^2) # Create a figure plt.figure(figsize=(10, 6)) # Loop over different initial velocities to plot horizontal motion for each case for v_0 in v_0_values: t_max = 2 * v_0 * np.sin(np.radians(theta)) / g # Total time of flight t = np.linspace(0, t_max, 1000) # Time values from 0 to t_max x_t = v_0 * np.cos(np.radians(theta)) * t # Horizontal position equation # Plot the horizontal motion for each initial velocity plt.plot(t, x_t, label=f'v_0 = {v_0} m/s', linewidth=2) # Add labels, title, and grid plt.title(r'Horizontal Motion of a Projectile: $x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t$', fontsize=14) plt.xlabel('Time (seconds)', fontsize=12) plt.ylabel('Horizontal Position (meters)', fontsize=12) plt.legend(loc='upper left', fontsize=10) plt.grid(True, which='both', linestyle='--', linewidth=0.5) # Use a default style for better compatibility plt.style.use('ggplot') # Show the plot plt.tight_layout() plt.show() This graph shows how horizontal motion changes over time. The horizontal motion equation \\( x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\) is used to describe it. Here, horizontal distance increases linearly with time \\( t \\) . The graph illustrates how the horizontal distances of projectiles with different initial velocities (10 m/s, 20 m/s, 30 m/s) change over time. Vertical Motion : $$ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ Where: - \\( y(t) \\) is the vertical position at time \\( t \\) , - \\( v_0 \\cdot \\sin(\\theta) \\) is the vertical component of the initial velocity, - \\( g \\) is the gravitational acceleration ( \\( \\approx 9.81 \\, \\text{m/s}^2 \\) on Earth), - \\( t \\) is the time elapsed . The projectile reaches the maximum height when the vertical velocity component becomes zero. From this point, it starts descending until it reaches the ground. The total time of flight can be found by solving the vertical motion equation for when \\( y(t) = 0 \\) . Show Python Code import numpy as np import matplotlib.pyplot as plt # Parameters for the plot v_0 = 20 # Initial velocity in m/s theta = 45 # Launch angle in degrees g = 9.81 # Acceleration due to gravity (m/s^2) # Total time of flight (when y(t) = 0) t_max = 2 * v_0 * np.sin(np.radians(theta)) / g # Total time for vertical motion # Time values from 0 to t_max t = np.linspace(0, t_max, 1000) # Vertical position equation: y(t) = v_0 * sin(\u03b8) * t - (1/2) * g * t^2 y_t = v_0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 # Create a figure with a clean and modern style plt.figure(figsize=(10, 6)) # Plot the vertical motion with a clean, minimalistic style plt.plot(t, y_t, label=r'$y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2$', color='teal', linewidth=2) # Highlight the maximum height (where the vertical velocity becomes zero) t_max_height = v_0 * np.sin(np.radians(theta)) / g y_max_height = v_0 * np.sin(np.radians(theta)) * t_max_height - 0.5 * g * t_max_height**2 # Use a bold marker for the maximum height plt.plot(t_max_height, y_max_height, 'o', markersize=10, color='coral') # Adjusting annotation position for better readability plt.annotate(f'Max Height: {y_max_height:.2f} m', xy=(t_max_height, y_max_height), xytext=(t_max_height + 0.5, y_max_height + 2), # Slightly moved up and right arrowprops=dict(arrowstyle='->', color='black'), fontsize=12, color='black') # Clean, minimalistic title and labels plt.title('Vertical Motion of a Projectile', fontsize=16, fontweight='bold', color='darkblue') plt.xlabel('Time (seconds)', fontsize=12, color='black') plt.ylabel('Vertical Position (meters)', fontsize=12, color='black') # Minimalist grid plt.grid(True, which='both', linestyle='-', linewidth=0.5, color='gray') # Remove box around the legend plt.legend(loc='upper right', fontsize=12, frameon=False) # Tight layout for a cleaner look plt.tight_layout() # Show the plot plt.show() This graph shows the vertical motion of a projectile. The red point marks the maximum height of approximately 10.19 meters .","title":"1. Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-time-of-flight-and-range","text":"To determine the time of flight, we set \\( y(t) = 0 \\) , which corresponds to the point when the projectile hits the ground. Solving for \\( t \\) gives: \\[ t_{\\text{total}} = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] This is the total time the projectile spends in the air. The range \\( R \\) , or the horizontal distance traveled, is then given by: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot t_{\\text{total}} = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Thus, the range \\( R \\) depends on the initial velocity \\( v_0 \\) , the gravitational acceleration \\( g \\) , and the launch angle \\( \\theta \\) .","title":"2. Time of Flight and Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-problem-projectile-motion","text":"A ball is projected with an initial speed of 20 m/s at an angle of 30\u00b0 above the horizontal. Assume there is no air resistance and take the acceleration due to gravity as 9.81 m/s\u00b2 . Questions: What is the total time the ball stays in the air? How far horizontally does the ball travel before hitting the ground? What is the maximum height the ball reaches?","title":"Example Problem: Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solution","text":"Given: - \\( v_0 = 20 \\, \\text{m/s} \\) - \\( \\theta = 30^\\circ \\) - \\( g = 9.81 \\, \\text{m/s}^2 \\) We use the following formulas: Time of Flight : $$ t_{\\text{total}} = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} $$ $$ t_{\\text{total}} = \\frac{2 \\cdot 20 \\cdot \\sin(30^\\circ)}{9.81} = \\frac{20}{9.81} \\approx \\boxed{2.04 \\, \\text{seconds}} $$ Range (Horizontal Distance) : $$ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} $$ $$ R = \\frac{400 \\cdot \\sin(60^\\circ)}{9.81} = \\frac{400 \\cdot 0.866}{9.81} \\approx \\frac{346.4}{9.81} \\approx \\boxed{35.3 \\, \\text{meters}} $$ Maximum Height : $$ H_{\\text{max}} = \\frac{v_0^2 \\cdot \\sin^2(\\theta)}{2g} $$ $$ H_{\\text{max}} = \\frac{400 \\cdot \\sin^2(30^\\circ)}{2 \\cdot 9.81} = \\frac{400 \\cdot 0.25}{19.62} = \\frac{100}{19.62} \\approx \\boxed{5.1 \\, \\text{meters}} $$","title":"Solution:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#final-answers","text":"Time of Flight: 2.04 s Range: 35.3 m Maximum Height: 5.1 m","title":"Final Answers:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analysis-of-the-range-as-a-function-of-the-angle-of-projection","text":"The range equation \\( R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\) shows that the range is a function of the angle \\( \\theta \\) . Specifically: The function \\( \\sin(2\\theta) \\) is maximized when \\( 2\\theta = 90^\\circ \\) , which corresponds to \\( \\theta = 45^\\circ \\) . Therefore, the range is maximized when the launch angle is \\( 45^\\circ \\) . If the angle is less than or greater than 45\u00b0, the range decreases. This means that, for a given initial velocity, the optimal launch angle for maximizing the range is 45\u00b0. However, the behavior of the range is also influenced by other factors, such as the initial velocity \\( v_0 \\) and the acceleration due to gravity \\( g \\) . For example, increasing the initial velocity \\( v_0 \\) will increase the range, while increasing \\( g \\) (such as on a planet with stronger gravity) will reduce the range.","title":"3. Analysis of the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range-as-a-function-of-the-angle-of-projection","text":"The range equation: \\[ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] shows that the range is a function of the launch angle \\( \\theta \\) . This equation tells us several important things: The function \\( \\sin(2\\theta) \\) reaches its maximum value when \\( 2\\theta = 90^\\circ \\) , or \\( \\theta = 45^\\circ \\) . Therefore, the maximum range occurs when the projectile is launched at a 45\u00b0 angle. If the angle is less than or greater than 45\u00b0 , the range decreases.","title":"Analysis of the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-launch-angle","text":"The plot below shows how the range changes with the angle of projection (assuming \\( v_0 = 20 \\, \\text{m/s} \\) ): Show Python Code import numpy as np import matplotlib.pyplot as plt v0 = 20 # m/s g = 9.81 # m/s^2 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) R = (v0**2) * np.sin(2 * angles_rad) / g plt.figure(figsize=(10, 5)) plt.plot(angles_deg, R, color='orange') plt.title('Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.tight_layout() plt.savefig(\"image-7.png\", dpi=300) plt.show() - The graph is symmetric about 45\u00b0 . - Launch angles like 30\u00b0 and 60\u00b0 produce the same range .","title":"Range vs. Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#why-are-30-and-60-the-same","text":"This is because: \\[ \\sin(2 \\cdot 30^\\circ) = \\sin(60^\\circ) = \\sin(120^\\circ) = \\sin(2 \\cdot 60^\\circ) \\] So for any two angles that add up to 90\u00b0 , the range will be the same.","title":"Why are 30\u00b0 and 60\u00b0 the same?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-considerations","text":"Increasing the initial velocity \\( v_0 \\) will increase the range. Increasing gravitational acceleration \\( g \\) (e.g., on Jupiter) will decrease the range. On the Moon , where \\( g \\approx 1.62 \\, \\text{m/s}^2 \\) , the same launch parameters would yield a much longer range .","title":"Real-World Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#think-about-it","text":"What would happen if air resistance were considered? Would 45\u00b0 still be the optimal angle for maximum range?","title":"Think About It"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-real-world-adaptations","text":"In real-world applications, projectile motion is not always idealized. For instance: Uneven Terrain : If a projectile is launched from a height or lands on uneven terrain, the equations above need to be adjusted to account for changes in the initial position and the varying height of the landing spot. Air Resistance : The presence of air resistance complicates the analysis, as it introduces a force that opposes the motion of the projectile, affecting both the horizontal and vertical components of the velocity. This effect is typically modeled by differential equations, but a simple analytic solution is not available. Numerical methods are often used to simulate these cases. Wind : Wind can alter the direction and speed of the projectile, affecting both range and trajectory. This factor can be modeled as an additional force applied to the projectile, changing the equations of motion.","title":"1. Real-World Adaptations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-computational-simulations","text":"A computational tool or simulation can be developed to model projectile motion, allowing for easy visualization of the range as a function of the angle of projection for various initial velocities and gravitational accelerations. Below is a simple Python code to simulate and plot the range as a function of the angle of projection for various initial velocities: Show Python Code import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # acceleration due to gravity (m/s^2) v_0 = 20 # initial velocity in m/s # Function to calculate the range def calculate_range(v_0, theta): return (v_0**2 * np.sin(2 * np.radians(theta))) / g # Angles of projection angles = np.linspace(0, 90, 100) # Calculate range for each angle ranges = [calculate_range(v_0, angle) for angle in angles] # Plot the range vs angle plt.figure(figsize=(8, 6)) plt.plot(angles, ranges) plt.title('Range of a Projectile as a Function of the Angle of Projection') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.show()","title":"2. Computational Simulations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"In this analysis, we explored the fundamental equations governing projectile motion and derived the relationship between the range and the launch angle. We found that the range is maximized at an angle of 45\u00b0, which is intuitive from both a theoretical and practical standpoint. By considering other factors like initial velocity and gravitational acceleration, we can predict how these variables influence the trajectory of a projectile. The idealized model of projectile motion provides a solid foundation for understanding the basic principles at play. However, real-world applications often require additional considerations, such as air resistance and uneven terrain. As a result, more sophisticated models and computational simulations are necessary for accurately predicting the behavior of projectiles in more complex environments. This investigation not only deepens our understanding of basic mechanics but also highlights the versatility and applicability of projectile motion in various domains, from sports and engineering to space exploration.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is governed by the following nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the angular frequency of the external force. Small-Angle Approximation For small angles \\(\\theta \\ll 1\\) , we can approximate \\(\\sin(\\theta) \\approx \\theta\\) . The equation becomes linear: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is the equation of a driven damped harmonic oscillator . For small angles ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) , which simplifies the nonlinear equation into a linear one: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is the differential equation of a driven damped harmonic oscillator . This approximation significantly simplifies the analysis of the system, allowing us to use linear system techniques. It is valid when the pendulum undergoes small oscillations. Under this condition, the system's response becomes periodic, and important characteristics such as amplitude, frequency, and phase shift can be computed analytically. Moreover, this model is not only applicable to mechanical pendulums but also widely used to describe analogous systems in other fields, such as AC electrical circuits, vibrating structural elements, and biomechanical oscillations. Now that the equation has been linearized under the small-angle approximation, we can proceed to solve it analytically using classical methods for linear differential equations. Solution Method (for Small-Angle Approximation) Once the equation is linearized under the small-angle assumption, we obtain: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This second-order linear nonhomogeneous differential equation is typically solved by breaking the solution into two parts: \\[ \\theta(t) = \\theta_h(t) + \\theta_p(t) \\] \\(\\theta_h(t)\\) : The homogeneous solution (natural response, dependent on initial conditions) \\(\\theta_p(t)\\) : The particular solution (steady-state response due to the driving force) Homogeneous Solution The homogeneous equation is: [ \\frac{d^2\\theta}{dt^ This equation describes the behavior of a damped harmonic oscillator . Its general solution is given by: \\[ \\theta_h(t) = e^{-\\frac{\\gamma t}{2}} \\left(C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t)\\right) \\] Here, \\(\\omega_d\\) is the damped natural frequency , defined as: \\[ \\omega_d = \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2} \\] This solution represents the transient behavior of the system, which decays over time depending on the initial conditions. It reflects the natural response of the system, determined solely by the initial state. Due to the damping term, the oscillations gradually decrease in amplitude, indicating that the system loses energy over time. Depending on the value of the damping coefficient \\(\\gamma\\) , different types of motion can be observed: Underdamped ( \\(\\gamma < 2\\omega_0\\) ): Oscillatory motion persists but with decreasing amplitude. Critically damped ( \\(\\gamma = 2\\omega_0\\) ): The system returns to equilibrium in the shortest time without oscillating. Overdamped ( \\(\\gamma > 2\\omega_0\\) ): The system slowly returns to equilibrium without oscillations. These three regimes have important implications for the system's stability and energy dissipation. Approximate Solution We solve the linearized ODE using a trial solution: \\[ \\theta(t) = \\theta_h(t) + \\theta_p(t) \\] Where: - \\(\\theta_h(t)\\) is the homogeneous solution (damped free oscillation), - \\(\\theta_p(t)\\) is the particular solution (steady-state response to the driving force). The steady-state (particular) solution is: \\[ \\theta_p(t) = B \\cos(\\omega t - \\delta) \\] With amplitude: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\] And phase lag: [ \\tan(\\delta) = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} ] This particular solution represents the steady-state response of the system under the influence of a periodic external force. Unlike the homogeneous (transient) solution, which decays over time due to damping, the particular solution persists and oscillates at the same frequency as the driving force. The amplitude \\(B\\) depends on the damping coefficient \\(\\gamma\\) , the driving frequency \\(\\omega\\) , and the natural frequency \\(\\omega_0\\) . Therefore, the system\u2019s response changes significantly depending on how close \\(\\omega\\) is to \\(\\omega_0\\) . Resonance Resonance occurs when the system absorbs energy most efficiently from the driving force: Underdamped resonance frequency : \\[ \\omega_r = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{2}} \\] At resonance, the amplitude \\(B\\) is maximized, and the energy stored in the system oscillates at large values. Resonance Behavior When the driving frequency \\(\\omega\\) approaches the system's natural frequency \\(\\omega_0\\) , the amplitude reaches its maximum value. This phenomenon is known as resonance . From the amplitude expression: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\] it is clear that the denominator becomes minimal when \\(\\omega \\approx \\omega_0\\) , especially for small \\(\\gamma\\) , resulting in a large amplitude. In the presence of damping, the resonance frequency shifts slightly lower than \\(\\omega_0\\) , and is given by: \\[ \\omega_r = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{2}} \\] At this frequency, the system resonates with the external force and absorbs energy most efficiently. As damping increases, the peak amplitude decreases, and the resonance curve becomes broader and flatter. Show Python Code import numpy as np import matplotlib.pyplot as plt # System parameters omega_0 = 1.0 # Natural frequency A = 1.0 # Amplitude of the external force # Different damping coefficients gammas = [0.0, 0.2, 0.5, 1.0] # From undamped to highly damped # Frequency range omega = np.linspace(0.1, 2.0, 500) # Plot plt.figure(figsize=(10, 6)) for gamma in gammas: B = A / np.sqrt((omega_0**2 - omega**2)**2 + (gamma**2) * omega**2) label = f\"\u03b3 = {gamma}\" plt.plot(omega, B, label=label) plt.title(\"Amplitude vs Driving Frequency (Resonance Curve)\") plt.xlabel(\"Driving Frequency (\u03c9)\") plt.ylabel(\"Amplitude (B)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() Resonance Curve The plot shows the amplitude ( \\(B\\) ) of the system's steady-state response as a function of the driving frequency ( \\(\\omega\\) ) for different damping coefficients ( \\(\\gamma\\) ). Blue (\u03b3 = 0.0): No damping, sharp resonance peak. Orange (\u03b3 = 0.2): Light damping, resonance peak reduces. Yellow (\u03b3 = 0.5): Moderate damping, broader resonance. Green (\u03b3 = 1.0): High damping, minimal resonance effect. 2. Analysis of Dynamics Parameter Influence Damping \\(\\gamma\\) : Higher damping suppresses oscillations and reduces the resonance peak. Driving amplitude \\(A\\) : Larger amplitude can lead to more energy in the system and chaotic behavior in the nonlinear regime. Driving frequency \\(\\omega\\) : Resonance and dynamic behavior depend critically on matching \\(\\omega\\) with \\(\\omega_0\\) . Show Python Code import numpy as np import matplotlib.pyplot as plt # System parameters omega_0 = 1.0 # Natural frequency A_values = np.linspace(0.1, 2.0, 10) # Driving amplitude gamma_values = np.linspace(0.0, 2.0, 10) # Damping coefficient omega = np.linspace(0.1, 2.0, 500) # Frequency range # Create a meshgrid for plotting A_grid, gamma_grid = np.meshgrid(A_values, gamma_values) # Calculate amplitude (B) B_grid = np.zeros_like(A_grid) # Calculate for all omega values for i in range(len(A_values)): for j in range(len(gamma_values)): B = A_values[i] / np.sqrt((omega_0**2 - omega**2)**2 + (gamma_values[j]**2) * omega**2) # Take the mean amplitude B_grid[i, j] = np.mean(B) # Plot heatmap plt.figure(figsize=(10, 6)) # Update color palette and levels plt.contourf(gamma_grid, A_grid, B_grid, levels=50, cmap='plasma') plt.colorbar(label='Amplitude (B)') plt.title('Heatmap of Amplitude vs Damping Coefficient and Driving Amplitude') plt.xlabel('Damping Coefficient (\u03b3) \u2013 Effect on Amplitude') plt.ylabel('Driving Amplitude (A) \u2013 Impact on Resonance') plt.tight_layout() plt.show() This heatmap shows how the system's amplitude ( \\(B\\) ) changes with the damping coefficient ( \\(\\gamma\\) ) and driving amplitude ( \\(A\\) ) . Darker colors represent lower amplitudes, while lighter colors indicate higher amplitudes. From Regular to Chaotic Motion In the nonlinear regime ( \\(\\sin(\\theta)\\) not approximated), the pendulum exhibits: Periodic motion : For small \\(A\\) and \\(\\gamma\\) . Quasiperiodic motion : Motion composed of multiple frequencies. Chaotic motion : Sensitive dependence on initial conditions; non-repeating trajectory. Differences Between Periodic and Chaotic Motion Periodic Motion : Periodic motion is a type of motion where the system moves in a regular and repeating manner. When the initial conditions are the same, the motion repeats in the same way each time. Example : Spring system or a pendulum swinging with small angles. Chaotic Motion : Chaotic motion is sensitive to initial conditions and is unpredictable. Small changes can lead to large differences, making the motion irregular. Example : Weather patterns and the double pendulum. Quasiperiodic Motion Quasiperiodic motion consists of a combination of multiple frequencies. The system exhibits regular motion but creates a complex pattern due to the influence of multiple frequencies. Example : Vibrating guitar strings and rotating fluids. 3. Practical Applications Real-World Relevance Energy harvesting : Using resonance in oscillators to extract ambient energy. Suspension bridges : Analyzing dynamic load responses (e.g., Tacoma Narrows Bridge). RLC circuits : Analogous system with voltage in place of angular displacement. Biomechanics : Human walking rhythm can exhibit similar synchronization effects. 4. Implementation (Python Simulation) Show Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters gamma = 0.2 # damping omega0 = 1.5 # natural frequency A = 1.2 # driving amplitude omega = 2/3 # driving frequency # ODE system: dtheta/dt = omega, domega/dt = ... def pendulum(t, y): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -gamma * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time range t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Initial conditions y0 = [0.2, 0.0] # initial angle, initial angular velocity # Solve ODE sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plotting plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time\") plt.ylabel(\"Angle \u03b8(t)\") plt.grid() plt.show() Phase Diagram Show Python Code plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1], lw=0.5) plt.title(\"Phase Portrait\") plt.xlabel(\"\u03b8\") plt.ylabel(\"d\u03b8/dt\") plt.grid() plt.show() Poincar\u00e9 Section Show Python Code # Sample once per driving period T_drive = 2 * np.pi / omega points = np.arange(0, t_span[1], T_drive) theta_sampled = np.interp(points, sol.t, sol.y[0]) omega_sampled = np.interp(points, sol.t, sol.y[1]) plt.figure(figsize=(6, 6)) plt.plot(theta_sampled % (2 * np.pi), omega_sampled, 'o', markersize=1) plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"\u03b8 mod 2\u03c0\") plt.ylabel(\"d\u03b8/dt\") plt.grid() plt.show() 5. Extensions and Limitations Limitations Small-angle approximation fails for large oscillations. Real systems might involve nonlinear damping or non-periodic forces. Numerical instability for very stiff systems or long-time integration. Possible Extensions Introduce nonlinear damping: \\( \\propto (\\frac{d\\theta}{dt})^3 \\) Replace periodic force with stochastic or pulse-driven input. Investigate coupling multiple pendula for synchronization studies. 6. Conclusion The forced damped pendulum is a foundational model that demonstrates transitions from order to chaos, governed by tunable parameters. It serves as a rich testing ground for both analytical techniques and computational simulations and has real-world relevance in many domains of science and engineering.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is governed by the following nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency of the pendulum, - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the angular frequency of the external force.","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles \\(\\theta \\ll 1\\) , we can approximate \\(\\sin(\\theta) \\approx \\theta\\) . The equation becomes linear: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is the equation of a driven damped harmonic oscillator . For small angles ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) , which simplifies the nonlinear equation into a linear one: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is the differential equation of a driven damped harmonic oscillator . This approximation significantly simplifies the analysis of the system, allowing us to use linear system techniques. It is valid when the pendulum undergoes small oscillations. Under this condition, the system's response becomes periodic, and important characteristics such as amplitude, frequency, and phase shift can be computed analytically. Moreover, this model is not only applicable to mechanical pendulums but also widely used to describe analogous systems in other fields, such as AC electrical circuits, vibrating structural elements, and biomechanical oscillations. Now that the equation has been linearized under the small-angle approximation, we can proceed to solve it analytically using classical methods for linear differential equations.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solution-method-for-small-angle-approximation","text":"Once the equation is linearized under the small-angle assumption, we obtain: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This second-order linear nonhomogeneous differential equation is typically solved by breaking the solution into two parts: \\[ \\theta(t) = \\theta_h(t) + \\theta_p(t) \\] \\(\\theta_h(t)\\) : The homogeneous solution (natural response, dependent on initial conditions) \\(\\theta_p(t)\\) : The particular solution (steady-state response due to the driving force)","title":"Solution Method (for Small-Angle Approximation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#homogeneous-solution","text":"The homogeneous equation is: [ \\frac{d^2\\theta}{dt^ This equation describes the behavior of a damped harmonic oscillator . Its general solution is given by: \\[ \\theta_h(t) = e^{-\\frac{\\gamma t}{2}} \\left(C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t)\\right) \\] Here, \\(\\omega_d\\) is the damped natural frequency , defined as: \\[ \\omega_d = \\sqrt{\\omega_0^2 - \\left(\\frac{\\gamma}{2}\\right)^2} \\] This solution represents the transient behavior of the system, which decays over time depending on the initial conditions. It reflects the natural response of the system, determined solely by the initial state. Due to the damping term, the oscillations gradually decrease in amplitude, indicating that the system loses energy over time. Depending on the value of the damping coefficient \\(\\gamma\\) , different types of motion can be observed: Underdamped ( \\(\\gamma < 2\\omega_0\\) ): Oscillatory motion persists but with decreasing amplitude. Critically damped ( \\(\\gamma = 2\\omega_0\\) ): The system returns to equilibrium in the shortest time without oscillating. Overdamped ( \\(\\gamma > 2\\omega_0\\) ): The system slowly returns to equilibrium without oscillations. These three regimes have important implications for the system's stability and energy dissipation.","title":"Homogeneous Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solution","text":"We solve the linearized ODE using a trial solution: \\[ \\theta(t) = \\theta_h(t) + \\theta_p(t) \\] Where: - \\(\\theta_h(t)\\) is the homogeneous solution (damped free oscillation), - \\(\\theta_p(t)\\) is the particular solution (steady-state response to the driving force). The steady-state (particular) solution is: \\[ \\theta_p(t) = B \\cos(\\omega t - \\delta) \\] With amplitude: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\] And phase lag: [ \\tan(\\delta) = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} ] This particular solution represents the steady-state response of the system under the influence of a periodic external force. Unlike the homogeneous (transient) solution, which decays over time due to damping, the particular solution persists and oscillates at the same frequency as the driving force. The amplitude \\(B\\) depends on the damping coefficient \\(\\gamma\\) , the driving frequency \\(\\omega\\) , and the natural frequency \\(\\omega_0\\) . Therefore, the system\u2019s response changes significantly depending on how close \\(\\omega\\) is to \\(\\omega_0\\) .","title":"Approximate Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when the system absorbs energy most efficiently from the driving force: Underdamped resonance frequency : \\[ \\omega_r = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{2}} \\] At resonance, the amplitude \\(B\\) is maximized, and the energy stored in the system oscillates at large values.","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-behavior","text":"When the driving frequency \\(\\omega\\) approaches the system's natural frequency \\(\\omega_0\\) , the amplitude reaches its maximum value. This phenomenon is known as resonance . From the amplitude expression: \\[ B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\] it is clear that the denominator becomes minimal when \\(\\omega \\approx \\omega_0\\) , especially for small \\(\\gamma\\) , resulting in a large amplitude. In the presence of damping, the resonance frequency shifts slightly lower than \\(\\omega_0\\) , and is given by: \\[ \\omega_r = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{2}} \\] At this frequency, the system resonates with the external force and absorbs energy most efficiently. As damping increases, the peak amplitude decreases, and the resonance curve becomes broader and flatter. Show Python Code import numpy as np import matplotlib.pyplot as plt # System parameters omega_0 = 1.0 # Natural frequency A = 1.0 # Amplitude of the external force # Different damping coefficients gammas = [0.0, 0.2, 0.5, 1.0] # From undamped to highly damped # Frequency range omega = np.linspace(0.1, 2.0, 500) # Plot plt.figure(figsize=(10, 6)) for gamma in gammas: B = A / np.sqrt((omega_0**2 - omega**2)**2 + (gamma**2) * omega**2) label = f\"\u03b3 = {gamma}\" plt.plot(omega, B, label=label) plt.title(\"Amplitude vs Driving Frequency (Resonance Curve)\") plt.xlabel(\"Driving Frequency (\u03c9)\") plt.ylabel(\"Amplitude (B)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Resonance Behavior"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-curve","text":"The plot shows the amplitude ( \\(B\\) ) of the system's steady-state response as a function of the driving frequency ( \\(\\omega\\) ) for different damping coefficients ( \\(\\gamma\\) ). Blue (\u03b3 = 0.0): No damping, sharp resonance peak. Orange (\u03b3 = 0.2): Light damping, resonance peak reduces. Yellow (\u03b3 = 0.5): Moderate damping, broader resonance. Green (\u03b3 = 1.0): High damping, minimal resonance effect.","title":"Resonance Curve"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-influence","text":"Damping \\(\\gamma\\) : Higher damping suppresses oscillations and reduces the resonance peak. Driving amplitude \\(A\\) : Larger amplitude can lead to more energy in the system and chaotic behavior in the nonlinear regime. Driving frequency \\(\\omega\\) : Resonance and dynamic behavior depend critically on matching \\(\\omega\\) with \\(\\omega_0\\) . Show Python Code import numpy as np import matplotlib.pyplot as plt # System parameters omega_0 = 1.0 # Natural frequency A_values = np.linspace(0.1, 2.0, 10) # Driving amplitude gamma_values = np.linspace(0.0, 2.0, 10) # Damping coefficient omega = np.linspace(0.1, 2.0, 500) # Frequency range # Create a meshgrid for plotting A_grid, gamma_grid = np.meshgrid(A_values, gamma_values) # Calculate amplitude (B) B_grid = np.zeros_like(A_grid) # Calculate for all omega values for i in range(len(A_values)): for j in range(len(gamma_values)): B = A_values[i] / np.sqrt((omega_0**2 - omega**2)**2 + (gamma_values[j]**2) * omega**2) # Take the mean amplitude B_grid[i, j] = np.mean(B) # Plot heatmap plt.figure(figsize=(10, 6)) # Update color palette and levels plt.contourf(gamma_grid, A_grid, B_grid, levels=50, cmap='plasma') plt.colorbar(label='Amplitude (B)') plt.title('Heatmap of Amplitude vs Damping Coefficient and Driving Amplitude') plt.xlabel('Damping Coefficient (\u03b3) \u2013 Effect on Amplitude') plt.ylabel('Driving Amplitude (A) \u2013 Impact on Resonance') plt.tight_layout() plt.show() This heatmap shows how the system's amplitude ( \\(B\\) ) changes with the damping coefficient ( \\(\\gamma\\) ) and driving amplitude ( \\(A\\) ) . Darker colors represent lower amplitudes, while lighter colors indicate higher amplitudes.","title":"Parameter Influence"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#from-regular-to-chaotic-motion","text":"In the nonlinear regime ( \\(\\sin(\\theta)\\) not approximated), the pendulum exhibits: Periodic motion : For small \\(A\\) and \\(\\gamma\\) . Quasiperiodic motion : Motion composed of multiple frequencies. Chaotic motion : Sensitive dependence on initial conditions; non-repeating trajectory.","title":"From Regular to Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differences-between-periodic-and-chaotic-motion","text":"","title":"Differences Between Periodic and Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#periodic-motion","text":"Periodic motion is a type of motion where the system moves in a regular and repeating manner. When the initial conditions are the same, the motion repeats in the same way each time. Example : Spring system or a pendulum swinging with small angles.","title":"Periodic Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaotic-motion","text":"Chaotic motion is sensitive to initial conditions and is unpredictable. Small changes can lead to large differences, making the motion irregular. Example : Weather patterns and the double pendulum.","title":"Chaotic Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#quasiperiodic-motion","text":"Quasiperiodic motion consists of a combination of multiple frequencies. The system exhibits regular motion but creates a complex pattern due to the influence of multiple frequencies. Example : Vibrating guitar strings and rotating fluids.","title":"Quasiperiodic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#real-world-relevance","text":"Energy harvesting : Using resonance in oscillators to extract ambient energy. Suspension bridges : Analyzing dynamic load responses (e.g., Tacoma Narrows Bridge). RLC circuits : Analogous system with voltage in place of angular displacement. Biomechanics : Human walking rhythm can exhibit similar synchronization effects.","title":"Real-World Relevance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"Show Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters gamma = 0.2 # damping omega0 = 1.5 # natural frequency A = 1.2 # driving amplitude omega = 2/3 # driving frequency # ODE system: dtheta/dt = omega, domega/dt = ... def pendulum(t, y): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -gamma * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time range t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Initial conditions y0 = [0.2, 0.0] # initial angle, initial angular velocity # Solve ODE sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plotting plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time\") plt.ylabel(\"Angle \u03b8(t)\") plt.grid() plt.show()","title":"4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-diagram","text":"Show Python Code plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1], lw=0.5) plt.title(\"Phase Portrait\") plt.xlabel(\"\u03b8\") plt.ylabel(\"d\u03b8/dt\") plt.grid() plt.show()","title":"Phase Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section","text":"Show Python Code # Sample once per driving period T_drive = 2 * np.pi / omega points = np.arange(0, t_span[1], T_drive) theta_sampled = np.interp(points, sol.t, sol.y[0]) omega_sampled = np.interp(points, sol.t, sol.y[1]) plt.figure(figsize=(6, 6)) plt.plot(theta_sampled % (2 * np.pi), omega_sampled, 'o', markersize=1) plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"\u03b8 mod 2\u03c0\") plt.ylabel(\"d\u03b8/dt\") plt.grid() plt.show()","title":"Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-extensions-and-limitations","text":"","title":"5. Extensions and Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"Small-angle approximation fails for large oscillations. Real systems might involve nonlinear damping or non-periodic forces. Numerical instability for very stiff systems or long-time integration.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-extensions","text":"Introduce nonlinear damping: \\( \\propto (\\frac{d\\theta}{dt})^3 \\) Replace periodic force with stochastic or pulse-driven input. Investigate coupling multiple pendula for synchronization studies.","title":"Possible Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-conclusion","text":"The forced damped pendulum is a foundational model that demonstrates transitions from order to chaos, governed by tunable parameters. It serves as a rich testing ground for both analytical techniques and computational simulations and has real-world relevance in many domains of science and engineering.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius: Kepler's Third Law Introduction Understanding the motion of celestial bodies is a fundamental goal in both classical mechanics and modern astronomy. Among the many relationships that describe orbital dynamics, Kepler\u2019s Third Law stands out as one of the most elegant and powerful. Formulated by Johannes Kepler in the early 17th century and later derived from Newton's law of universal gravitation, this law reveals a deep connection between the size of an orbit and the time it takes for a body to complete one revolution. Kepler's Third Law states that the square of the orbital period of a planet is proportional to the cube of the semi-major axis of its orbit. This relationship holds true not only for planets orbiting the Sun, but also for moons orbiting planets, artificial satellites, and binary star systems. Its simplicity belies its profound implications: with only the orbital period and radius, one can infer critical information such as the mass of the central body or the scale of an entire planetary system. In this report, we will derive Kepler's Third Law from fundamental physical principles, explore its significance in real-world astronomical contexts, and implement a numerical simulation to verify its validity for circular orbits. The analysis will include visualizations of orbital dynamics and a discussion on how the law extends to elliptical orbits and other celestial configurations. Motivation Kepler's Third Law establishes a relationship between the orbital period \\( T \\) and the orbital radius \\( r \\) of a body in circular motion around a much more massive central object (e.g., a planet orbiting a star). This law is fundamental in celestial mechanics and is key to calculating planetary masses, satellite trajectories, and interplanetary distances. Derivation of Kepler's Third Law for Circular Orbits We begin with Newton's Law of Universal Gravitation and the requirement for centripetal force to sustain circular motion: Gravitational force: Fg = (G * M * m) / r\u00b2 Centripetal force required for circular motion: Fc = (m * v\u00b2) / r Equating the two forces: (G * M * m) / r\u00b2 = (m * v\u00b2) / r Cancel m and multiply both sides by r: (G * M) / r = v\u00b2 The orbital period \\( T \\) is the time it takes to complete one full orbit: [ T = \\frac{2 \\pi r}{v} \\Rightarrow v = \\frac{2 \\pi r}{T} ] Substitute for \\( v^2 \\) : [ \\left( \\frac{2 \\pi r}{T} \\right)^2 = \\frac{G M}{r} \\Rightarrow \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} \\Rightarrow T^2 = \\frac{4 \\pi^2 r^3}{G M} ] Kepler's Third Law: [ T^2 \\propto r^3 ] Explanation and Interpretation To derive Kepler\u2019s Third Law from first principles, we start with Newton\u2019s Law of Universal Gravitation and the requirement for centripetal force needed to maintain circular motion. Assumptions The orbit is perfectly circular. The mass of the orbiting body \\( m \\) is much smaller than the central mass \\( M \\) , such that \\( M \\gg m \\) . The only significant force acting on the orbiting body is the gravitational attraction from the central body. Relativistic effects and perturbations from other bodies are neglected. Step-by-step Derivation Gravitational force: F_g = (G * M * m) / r^2 Centripetal force required for circular motion: F_c = (m * v^2) / r Equating gravitational force with the required centripetal force: (G * M * m) / r^2 = (m * v^2) / r Cancel m from both sides (since m \u2260 0) and multiply both sides by r: (G * M) / r = v^2 The orbital period T is the time it takes to complete one full revolution around the central body: T = (2 * \u03c0 * r) / v \u21d2 v = (2 * \u03c0 * r) / T Substitute this expression for v into the earlier equation: ((2 * \u03c0 * r) / T)^2 = (G * M) / r (4 * \u03c0^2 * r^2) / T^2 = (G * M) / r Multiply both sides by r to isolate T^2: (4 * \u03c0^2 * r^3) / T^2 = G * M \u21d2 T^2 = (4 * \u03c0^2 * r^3) / (G * M) Interpretation This final expression \\( T^2 = \\frac{4 \\pi^2 r^3}{G M} \\) shows that the square of the orbital period is directly proportional to the cube of the orbital radius. The proportionality constant \\( \\frac{4 \\pi^2}{G M} \\) depends solely on the gravitational constant and the mass of the central object, meaning that for all bodies orbiting the same central mass, the relationship between \\( T^2 \\) and \\( r^3 \\) is identical. This law can also be rearranged to solve for the mass of the central body: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] This is especially important in astronomy and astrophysics, where we can use the motion of satellites, planets, or stars to infer the mass of a central object (e.g., the Sun, a planet, or a black hole) without directly measuring it. Although this derivation treats force magnitudes as scalar quantities, a full vector analysis confirms that both gravitational and centripetal accelerations point toward the center of the circular path, which validates the scalar approach used here for symmetric circular motion. Transition In the following sections, we will explore real-world examples such as planetary orbits and the Moon\u2019s motion, and implement a computational simulation to verify Kepler\u2019s Third Law numerically. Additionally, we will extend this relationship to elliptical orbits using the semi-major axis in place of the orbital radius. Implications for Astronomy If the mass M of the central object is known, one can predict orbital periods for satellites or planets. If the orbital period and radius are measured, one can estimate the mass of the central body: M = (4 * \u03c0^2 * r^3) / (G * T^2) This relation holds remarkably well in planetary systems and is crucial in: Determining stellar and planetary masses. Calculating distances in exoplanet studies. Planning space missions. Example: Orbital Periods of Satellites at Different Altitudes To illustrate the practical application of Kepler\u2019s Third Law, consider a set of artificial satellites orbiting the Earth at different altitudes. We can compute their orbital periods and plot the relationship between orbital radius and period. The Earth\u2019s radius is approximately \\( R_E = 6.371 \\times 10^6 \\, \\text{m} \\) . We will calculate the total orbital radius \\( r = R_E + h \\) for different altitudes \\( h \\) and use Kepler\u2019s Law to find the orbital period \\( T \\) . According to: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M_E}} \\] This plot helps visualize how even a small change in altitude can significantly affect the orbital period, especially in high orbits such as geostationary satellites. Show python code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Altitudes in km for LEO, MEO, and GEO altitudes_km = np.linspace(200, 40000, 100) # from 200 km to 40,000 km radii = R_earth + altitudes_km * 1e3 # convert km to meters # Compute orbital periods (in seconds) T = 2 * np.pi * np.sqrt(radii**3 / (G * M_earth)) T_hours = T / 3600 # convert seconds to hours # Plot plt.figure(figsize=(8,6)) plt.plot(altitudes_km, T_hours) plt.xlabel(\"Altitude above Earth's surface (km)\") plt.ylabel(\"Orbital Period (hours)\") plt.title(\"Orbital Period vs. Satellite Altitude\") plt.grid(True) plt.show() Real-World Examples 1. The Moon around Earth Given: - \\( r = 3.84 \\times 10^8 \\, \\text{m} \\) - \\( T = 27.3 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s} \\) Estimate Earth's mass: M = (4 * \u03c0^2 * r^3) / (G * T^2) \u2248 5.97 \u00d7 10^24 kg 2. Planets in the Solar System Planet Orbital Radius (AU) Orbital Period (Years) \\( T^2/r^3 \\) Earth 1 1 1 Mars 1.52 1.88 ~1 Jupiter 5.20 11.86 ~1 This data shows that \\( T^2 / r^3 \\) remains approximately constant, confirming Kepler\u2019s Third Law across different planets. Graphical Visualization The bar chart below visualizes the value of T\u00b2 / r\u00b3 for Earth, Mars, and Jupiter. As expected, the values are all very close to 1, demonstrating the consistency of Kepler\u2019s Third Law. \\[ T^2 / r^3 \\approx \\text{constant} \\] Show python code import numpy as np import matplotlib.pyplot as plt # Selected planets planet_names = [\"Earth\", \"Mars\", \"Jupiter\"] radii_au = np.array([1.00, 1.52, 5.20]) # Orbital radius in AU periods_years = np.array([1.00, 1.88, 11.86]) # Orbital period in years # Calculate T\u00b2 / r\u00b3 r_cubed = radii_au**3 T_squared = periods_years**2 kepler_ratio = T_squared / r_cubed # Create bar chart plt.figure(figsize=(8, 5)) bars = plt.bar(planet_names, kepler_ratio, color='cornflowerblue', edgecolor='black') # Add value labels above bars for bar, value in zip(bars, kepler_ratio): plt.text(bar.get_x() + bar.get_width() / 2, bar.get_height() + 0.005, f\"{value:.2f}\", ha='center', va='bottom', fontsize=10) # Customize plot plt.title(\"T\u00b2 / r\u00b3 Ratio for Earth, Mars, and Jupiter (Kepler's Third Law)\", fontsize=14) plt.ylabel(\"T\u00b2 / r\u00b3 (Years\u00b2 / AU\u00b3)\") plt.ylim(0.95, 1.05) plt.grid(axis='y', linestyle='--', alpha=0.7) plt.tight_layout() # Show plot plt.show() Computational Simulation (Python) Show python code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 1.989e30 # mass of the Sun (kg) # Orbital radii (in meters) radii = np.linspace(0.1, 5, 100) * 1.496e11 # from 0.1 AU to 5 AU periods_squared = (4 * np.pi**2 * radii**3) / (G * M) # Plotting T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, periods_squared, label=r'$T^2$ vs $r^3$') plt.xlabel(r'$r^3$ [m$^3$]') plt.ylabel(r'$T^2$ [s$^2$]') plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.show() Extension to Elliptical Orbits Kepler's Third Law also holds for elliptical orbits, where the semi-major axis a replaces the circular radius r : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G M} \\] This is especially useful for calculating the dynamics of: Comets (e.g., Halley's Comet) Binary star systems Exoplanets orbiting other stars In elliptical orbits, even though the distance between the orbiting object and the central body changes over time, the average distance represented by the semi-major axis still governs the orbital period. This generalization makes Kepler\u2019s Law applicable to a wide range of celestial phenomena beyond nearly circular planetary orbits. It also provides the foundation for analyzing long-period comets and predicting their return, as well as calculating orbital characteristics of distant exoplanets detected via transit or radial velocity methods. Conclusion Kepler's Third Law elegantly links orbital period to orbital size, revealing the gravitational harmony of planetary systems. Whether calculating the mass of Earth from the Moon\u2019s motion or simulating artificial satellite paths, this relationship remains central in both theoretical and applied astronomy. Beyond our Solar System, Kepler\u2019s Law plays a crucial role in characterizing exoplanets and their host stars, contributing to our understanding of planetary system formation and evolution. Its simplicity allows scientists to extract complex gravitational behavior from limited observational data. As our ability to observe distant systems improves with modern telescopes and space missions, Kepler\u2019s insights continue to serve as a foundational tool in unlocking the dynamics of the universe.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"Understanding the motion of celestial bodies is a fundamental goal in both classical mechanics and modern astronomy. Among the many relationships that describe orbital dynamics, Kepler\u2019s Third Law stands out as one of the most elegant and powerful. Formulated by Johannes Kepler in the early 17th century and later derived from Newton's law of universal gravitation, this law reveals a deep connection between the size of an orbit and the time it takes for a body to complete one revolution. Kepler's Third Law states that the square of the orbital period of a planet is proportional to the cube of the semi-major axis of its orbit. This relationship holds true not only for planets orbiting the Sun, but also for moons orbiting planets, artificial satellites, and binary star systems. Its simplicity belies its profound implications: with only the orbital period and radius, one can infer critical information such as the mass of the central body or the scale of an entire planetary system. In this report, we will derive Kepler's Third Law from fundamental physical principles, explore its significance in real-world astronomical contexts, and implement a numerical simulation to verify its validity for circular orbits. The analysis will include visualizations of orbital dynamics and a discussion on how the law extends to elliptical orbits and other celestial configurations.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law establishes a relationship between the orbital period \\( T \\) and the orbital radius \\( r \\) of a body in circular motion around a much more massive central object (e.g., a planet orbiting a star). This law is fundamental in celestial mechanics and is key to calculating planetary masses, satellite trajectories, and interplanetary distances.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"We begin with Newton's Law of Universal Gravitation and the requirement for centripetal force to sustain circular motion: Gravitational force: Fg = (G * M * m) / r\u00b2 Centripetal force required for circular motion: Fc = (m * v\u00b2) / r Equating the two forces: (G * M * m) / r\u00b2 = (m * v\u00b2) / r Cancel m and multiply both sides by r: (G * M) / r = v\u00b2 The orbital period \\( T \\) is the time it takes to complete one full orbit: [ T = \\frac{2 \\pi r}{v} \\Rightarrow v = \\frac{2 \\pi r}{T} ] Substitute for \\( v^2 \\) : [ \\left( \\frac{2 \\pi r}{T} \\right)^2 = \\frac{G M}{r} \\Rightarrow \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} \\Rightarrow T^2 = \\frac{4 \\pi^2 r^3}{G M} ] Kepler's Third Law: [ T^2 \\propto r^3 ]","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation-and-interpretation","text":"To derive Kepler\u2019s Third Law from first principles, we start with Newton\u2019s Law of Universal Gravitation and the requirement for centripetal force needed to maintain circular motion.","title":"Explanation and Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#assumptions","text":"The orbit is perfectly circular. The mass of the orbiting body \\( m \\) is much smaller than the central mass \\( M \\) , such that \\( M \\gg m \\) . The only significant force acting on the orbiting body is the gravitational attraction from the central body. Relativistic effects and perturbations from other bodies are neglected.","title":"Assumptions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-by-step-derivation","text":"Gravitational force: F_g = (G * M * m) / r^2 Centripetal force required for circular motion: F_c = (m * v^2) / r Equating gravitational force with the required centripetal force: (G * M * m) / r^2 = (m * v^2) / r Cancel m from both sides (since m \u2260 0) and multiply both sides by r: (G * M) / r = v^2 The orbital period T is the time it takes to complete one full revolution around the central body: T = (2 * \u03c0 * r) / v \u21d2 v = (2 * \u03c0 * r) / T Substitute this expression for v into the earlier equation: ((2 * \u03c0 * r) / T)^2 = (G * M) / r (4 * \u03c0^2 * r^2) / T^2 = (G * M) / r Multiply both sides by r to isolate T^2: (4 * \u03c0^2 * r^3) / T^2 = G * M \u21d2 T^2 = (4 * \u03c0^2 * r^3) / (G * M)","title":"Step-by-step Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#interpretation","text":"This final expression \\( T^2 = \\frac{4 \\pi^2 r^3}{G M} \\) shows that the square of the orbital period is directly proportional to the cube of the orbital radius. The proportionality constant \\( \\frac{4 \\pi^2}{G M} \\) depends solely on the gravitational constant and the mass of the central object, meaning that for all bodies orbiting the same central mass, the relationship between \\( T^2 \\) and \\( r^3 \\) is identical. This law can also be rearranged to solve for the mass of the central body: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] This is especially important in astronomy and astrophysics, where we can use the motion of satellites, planets, or stars to infer the mass of a central object (e.g., the Sun, a planet, or a black hole) without directly measuring it. Although this derivation treats force magnitudes as scalar quantities, a full vector analysis confirms that both gravitational and centripetal accelerations point toward the center of the circular path, which validates the scalar approach used here for symmetric circular motion.","title":"Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#transition","text":"In the following sections, we will explore real-world examples such as planetary orbits and the Moon\u2019s motion, and implement a computational simulation to verify Kepler\u2019s Third Law numerically. Additionally, we will extend this relationship to elliptical orbits using the semi-major axis in place of the orbital radius.","title":"Transition"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-for-astronomy","text":"If the mass M of the central object is known, one can predict orbital periods for satellites or planets. If the orbital period and radius are measured, one can estimate the mass of the central body: M = (4 * \u03c0^2 * r^3) / (G * T^2) This relation holds remarkably well in planetary systems and is crucial in: Determining stellar and planetary masses. Calculating distances in exoplanet studies. Planning space missions.","title":"Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-orbital-periods-of-satellites-at-different-altitudes","text":"To illustrate the practical application of Kepler\u2019s Third Law, consider a set of artificial satellites orbiting the Earth at different altitudes. We can compute their orbital periods and plot the relationship between orbital radius and period. The Earth\u2019s radius is approximately \\( R_E = 6.371 \\times 10^6 \\, \\text{m} \\) . We will calculate the total orbital radius \\( r = R_E + h \\) for different altitudes \\( h \\) and use Kepler\u2019s Law to find the orbital period \\( T \\) . According to: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M_E}} \\] This plot helps visualize how even a small change in altitude can significantly affect the orbital period, especially in high orbits such as geostationary satellites. Show python code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Altitudes in km for LEO, MEO, and GEO altitudes_km = np.linspace(200, 40000, 100) # from 200 km to 40,000 km radii = R_earth + altitudes_km * 1e3 # convert km to meters # Compute orbital periods (in seconds) T = 2 * np.pi * np.sqrt(radii**3 / (G * M_earth)) T_hours = T / 3600 # convert seconds to hours # Plot plt.figure(figsize=(8,6)) plt.plot(altitudes_km, T_hours) plt.xlabel(\"Altitude above Earth's surface (km)\") plt.ylabel(\"Orbital Period (hours)\") plt.title(\"Orbital Period vs. Satellite Altitude\") plt.grid(True) plt.show()","title":"Example: Orbital Periods of Satellites at Different Altitudes"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-the-moon-around-earth","text":"Given: - \\( r = 3.84 \\times 10^8 \\, \\text{m} \\) - \\( T = 27.3 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s} \\) Estimate Earth's mass: M = (4 * \u03c0^2 * r^3) / (G * T^2) \u2248 5.97 \u00d7 10^24 kg","title":"1. The Moon around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-planets-in-the-solar-system","text":"Planet Orbital Radius (AU) Orbital Period (Years) \\( T^2/r^3 \\) Earth 1 1 1 Mars 1.52 1.88 ~1 Jupiter 5.20 11.86 ~1 This data shows that \\( T^2 / r^3 \\) remains approximately constant, confirming Kepler\u2019s Third Law across different planets.","title":"2. Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graphical-visualization","text":"The bar chart below visualizes the value of T\u00b2 / r\u00b3 for Earth, Mars, and Jupiter. As expected, the values are all very close to 1, demonstrating the consistency of Kepler\u2019s Third Law. \\[ T^2 / r^3 \\approx \\text{constant} \\] Show python code import numpy as np import matplotlib.pyplot as plt # Selected planets planet_names = [\"Earth\", \"Mars\", \"Jupiter\"] radii_au = np.array([1.00, 1.52, 5.20]) # Orbital radius in AU periods_years = np.array([1.00, 1.88, 11.86]) # Orbital period in years # Calculate T\u00b2 / r\u00b3 r_cubed = radii_au**3 T_squared = periods_years**2 kepler_ratio = T_squared / r_cubed # Create bar chart plt.figure(figsize=(8, 5)) bars = plt.bar(planet_names, kepler_ratio, color='cornflowerblue', edgecolor='black') # Add value labels above bars for bar, value in zip(bars, kepler_ratio): plt.text(bar.get_x() + bar.get_width() / 2, bar.get_height() + 0.005, f\"{value:.2f}\", ha='center', va='bottom', fontsize=10) # Customize plot plt.title(\"T\u00b2 / r\u00b3 Ratio for Earth, Mars, and Jupiter (Kepler's Third Law)\", fontsize=14) plt.ylabel(\"T\u00b2 / r\u00b3 (Years\u00b2 / AU\u00b3)\") plt.ylim(0.95, 1.05) plt.grid(axis='y', linestyle='--', alpha=0.7) plt.tight_layout() # Show plot plt.show()","title":"Graphical Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-simulation-python","text":"Show python code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 1.989e30 # mass of the Sun (kg) # Orbital radii (in meters) radii = np.linspace(0.1, 5, 100) * 1.496e11 # from 0.1 AU to 5 AU periods_squared = (4 * np.pi**2 * radii**3) / (G * M) # Plotting T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, periods_squared, label=r'$T^2$ vs $r^3$') plt.xlabel(r'$r^3$ [m$^3$]') plt.ylabel(r'$T^2$ [s$^2$]') plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.show()","title":"Computational Simulation (Python)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler's Third Law also holds for elliptical orbits, where the semi-major axis a replaces the circular radius r : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G M} \\] This is especially useful for calculating the dynamics of: Comets (e.g., Halley's Comet) Binary star systems Exoplanets orbiting other stars In elliptical orbits, even though the distance between the orbiting object and the central body changes over time, the average distance represented by the semi-major axis still governs the orbital period. This generalization makes Kepler\u2019s Law applicable to a wide range of celestial phenomena beyond nearly circular planetary orbits. It also provides the foundation for analyzing long-period comets and predicting their return, as well as calculating orbital characteristics of distant exoplanets detected via transit or radial velocity methods.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law elegantly links orbital period to orbital size, revealing the gravitational harmony of planetary systems. Whether calculating the mass of Earth from the Moon\u2019s motion or simulating artificial satellite paths, this relationship remains central in both theoretical and applied astronomy. Beyond our Solar System, Kepler\u2019s Law plays a crucial role in characterizing exoplanets and their host stars, contributing to our understanding of planetary system formation and evolution. Its simplicity allows scientists to extract complex gravitational behavior from limited observational data. As our ability to observe distant systems improves with modern telescopes and space missions, Kepler\u2019s insights continue to serve as a foundational tool in unlocking the dynamics of the universe.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}